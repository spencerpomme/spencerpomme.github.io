<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>品森</title>
  <subtitle>一人的呓语</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spencerpomme.github.io/"/>
  <updated>2016-05-20T14:29:24.000Z</updated>
  <id>http://spencerpomme.github.io/</id>
  
  <author>
    <name>工常邵</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>heapsort</title>
    <link href="http://spencerpomme.github.io/2016/05/19/heapsort/"/>
    <id>http://spencerpomme.github.io/2016/05/19/heapsort/</id>
    <published>2016-05-19T04:29:59.000Z</published>
    <updated>2016-05-20T14:29:24.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前一篇blog&lt;strong&gt;《将未排序数组转化为堆》&lt;/strong&gt;讲了如何将未排序的数组转化成最大堆，本文接着上次的内容继续。主要涉及到的内容包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接着上一篇，分析create_maxheap函数的时间复杂度；&lt;/li&gt;
&lt;li&gt;实现heapsort算法&lt;/li&gt;
&lt;li&gt;分析heapsort的时间复杂度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;参考书目：CLRS 6.1-6.4&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;可以预见本文将不得不利用一点数学推导来进行分析，太可怕了🌚&lt;/p&gt;
&lt;h3 id=&quot;create-maxheap的时间复杂度分析&quot;&gt;&lt;a href=&quot;#create-maxheap的时间复杂度分析&quot; class=&quot;headerlink&quot; title=&quot;create_maxheap的时间复杂度分析&quot;&gt;&lt;/a&gt;create_maxheap的时间复杂度分析&lt;/h3&gt;&lt;h4 id=&quot;粗略分析：loose-bound&quot;&gt;&lt;a href=&quot;#粗略分析：loose-bound&quot; class=&quot;headerlink&quot; title=&quot;粗略分析：loose bound&quot;&gt;&lt;/a&gt;粗略分析：loose bound&lt;/h4&gt;&lt;p&gt;首先来回顾一下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;create_maxheap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[], &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = n / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        max_heapify2(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;, n, i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一眼看起来，这个函数的时间复杂度应该是$O(n\cdot O(max\ heapify))$，而max_heapify的时间复杂度在之前的blog中已经分析过了，是O(lg n)。所以至少可以得到一个大致的时间复杂度应该是$o(n\cdot \lg n)$。（O表示tight upper bound，而o则不是）。然而我们可以做得更加精确一些。&lt;/p&gt;
&lt;p&gt;我们已经知道，对于一个有n个节点的heap来说，其中某个节点调用max_heapify的时间复杂度为O(h)，h为该节点的height。&lt;strong&gt;因此，每一层调用max_heapify执行的工作量是不一样的。&lt;/strong&gt;譬如在height=1的那一层（即leaf节点层的上一层）调用max_heapify的步骤为&lt;code&gt;1c&lt;/code&gt;，而在root的调用时间则是$\lg n \cdot c$，c是常数。&lt;/p&gt;
&lt;p&gt;所以为了知道总的时间，还需要知道&lt;strong&gt;每一层的节点数与height的关系&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;每一层的节点数与height的关系&quot;&gt;&lt;a href=&quot;#每一层的节点数与height的关系&quot; class=&quot;headerlink&quot; title=&quot;每一层的节点数与height的关系&quot;&gt;&lt;/a&gt;每一层的节点数与height的关系&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 推导时，假设heap构成了一棵full binary tree。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/fullbt.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;: 这是为了求得每一层最多时候的情况而规定的，同时当n趋近于$\infty$的时候，leaf层是否满足full binary tree的定义对得到的规律而言无影响，但是会大大简化推导的过程。&lt;/p&gt;
&lt;p&gt;对于一棵节点总数为n的full binary tree来说，其每一层的节点数是一个$r=2$的等比数列，所以节点数之和与深度depth的关系为：&lt;br&gt;$$&lt;br&gt;\begin{eqnarray&lt;em&gt;}&lt;br&gt;\large n&lt;br&gt;&amp;amp;=&amp;amp;\sum_{d=1}^{\lg n} r^d = \frac{1-r^d}{1-r} \ \ \ \ \ (r\neq1)\\&lt;br&gt;&amp;amp;&amp;amp;带入r=2, 有:\\&lt;br&gt;&amp;amp;=&amp;amp; \frac{1-2^d}{1-2}\&lt;br&gt;&amp;amp;=&amp;amp; 2^d-1&lt;br&gt;\end{eqnarray&lt;/em&gt;}&lt;br&gt;$$&lt;br&gt;其中，d为该层的节点的深度(depth)。对于一棵full binary tree我们知道，节点的depth和height存在关系：$d+h=\lg n$，其中n为总的节点数，h为height。所以(A)式可以改写为：&lt;br&gt;$$&lt;br&gt;\large n \normalsize = 2^{\lg n - h} - 1\ \ \ \ \&lt;br&gt;$$&lt;br&gt;现在来求$h = h&lt;em&gt;{0}$时，该层有多少个节点。方法很简单，只需要用从顶点到$h&lt;/em&gt;{0}$层的总节点数减去从顶点到$h&lt;em&gt;{0} +1$层的总节点数即可算出：&lt;br&gt;$$&lt;br&gt;\begin{eqnarray*}&lt;br&gt;S&lt;/em&gt;{0}&lt;br&gt;&amp;amp;=&amp;amp;(2^{\lg n - h&lt;em&gt;{0}} - 1) - (2^{\lg n - (h&lt;/em&gt;{0}+1)} -1)\&lt;br&gt;&amp;amp;=&amp;amp;\frac{2^{\lg n}}{2^{h&lt;em&gt;{0}+1}}\&lt;br&gt;&amp;amp;=&amp;amp;\frac{n}{2^{h&lt;/em&gt;{0}+1}}\&lt;br&gt;\end{eqnarray*}&lt;br&gt;$$&lt;br&gt;由此，可以证明每一层最多含有$\lceil\frac{n}{2^{h+1}}\rceil$个节点。（这个证明是CLRS中的一道习题）&lt;/p&gt;
&lt;h4 id=&quot;推导create-maxheap的时间复杂度&quot;&gt;&lt;a href=&quot;#推导create-maxheap的时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;推导create_maxheap的时间复杂度&quot;&gt;&lt;/a&gt;推导create_maxheap的时间复杂度&lt;/h4&gt;&lt;p&gt;证明了对于一个heap来说每一层最多有$\lceil\frac{n}{2^{h+1}}\rceil$个节点之后，就可以进一步推导create_maxheap的时间复杂度了。有：&lt;br&gt;$$&lt;br&gt;T(h) = \frac{n}{2^{1+1}}(1c) +  \frac{n}{2^{2+1}}(2c) + \cdots +  \frac{n}{2^{\lg(n)}}(\lg(\frac{n}{2})\cdot c) +  \frac{n}{2^{\lg(n)+1}}(\lg(n)\cdot c) \ \ \ \ \ (a)&lt;br&gt;$$&lt;br&gt;其中，$h\in[1,\lg(n)]$闭区间。这个很容易理解，当h也就是height为1的时候，就是leaf层的上一层；当h为$\lg(n)$的时候，就是root节点了。(a)式的每一项由两个部分组成，第一部分为层节点数，第二部分为每个该层节点需要做的work，c为一个常数。&lt;/p&gt;
&lt;p&gt;对于(a)式提取公因式$\frac{cn}{2^{1+1}}$，可以得到：&lt;br&gt;$$&lt;br&gt;T(h) = \frac{cn}{4}\cdot (\normalsize 1 + \frac{2}{2} + \frac{3}{4} + \frac{4}{8} + \frac{5}{16} + \cdots + \frac{h}{2^{h-1}}) \ \ \ \ \  (b)&lt;br&gt;$$&lt;br&gt;即：&lt;br&gt;$$&lt;br&gt;T(h) = \frac{cn}{4}\cdot (1 + \sum&lt;em&gt;{h=1}^{\lg(n)} \frac{h}{2^{h-1}}) \ \ \ \ \  (c)&lt;br&gt;$$&lt;br&gt;容易发现，$\sum&lt;/em&gt;{h=1}^{\lg(n)} \frac{h}{2^{h-1}}$这一项可以拆解为等差数列和等比数列的商，进一步简化可以写为$\sum&lt;em&gt;{h=0}^{\lg(n)} \frac{h}{2^{h}}$，然后当：&lt;br&gt;$$&lt;br&gt;\sum&lt;/em&gt;{h=0}^{\infty} \frac{h}{2^{h}} \ \ \ \ \ (d)&lt;br&gt;$$&lt;br&gt;(d)式满足公式：$\sum&lt;em&gt;{k=0}^{\infty} kx^k = \frac{x}{(1-x)^2}$（&lt;strong&gt;公式证明可见维基百科&lt;/strong&gt;），当且仅当$\vert k \vert &amp;lt; 1$时成立。这里$k = \frac{1}{2}$，因此(d)式收敛于：&lt;br&gt;$$&lt;br&gt;\sum&lt;/em&gt;{h=0}^{\infty} \frac{h}{2^h} = \frac{1/2}{(1- 1/2)^2} = 2 \ \ \ \ \ (e)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;于是结合(e), (c)两式有：&lt;br&gt;$$&lt;br&gt;\begin {eqnarray&lt;em&gt;}&lt;br&gt; \large O(\normalsize \frac{cn}{4}\cdot(1+\sum&lt;em&gt;{h=1}^{\lg(n)} \frac{h}{2^{h-1}})\large)\normalsize&lt;br&gt; &amp;amp;=&amp;amp;\large O(\normalsize\frac{cn}{4}\cdot(1+\sum&lt;/em&gt;{h=0}^{\infty} \frac{h}{2^{h}})\large) \&lt;br&gt; &amp;amp;=&amp;amp;\large O(\normalsize\frac{cn}{4}\cdot(1+2)\large)\ \&lt;br&gt; &amp;amp;=&amp;amp;\large O(\normalsize\frac{3cn}{4}\large)\ \&lt;br&gt; &amp;amp;=&amp;amp;\large O(\normalsize n \large)&lt;br&gt;\end {eqnarray&lt;/em&gt;}&lt;br&gt;$$&lt;br&gt;至此，证明完毕。可知create_maxheap的时间复杂度是线性的。&lt;/p&gt;
&lt;h3 id=&quot;heapsort算法&quot;&gt;&lt;a href=&quot;#heapsort算法&quot; class=&quot;headerlink&quot; title=&quot;heapsort算法&quot;&gt;&lt;/a&gt;heapsort算法&lt;/h3&gt;&lt;p&gt;同样，这个部分也分为两个子内容，首先实现heapsort算法，然后分析其时间复杂度。&lt;/p&gt;
&lt;h4 id=&quot;算法实现&quot;&gt;&lt;a href=&quot;#算法实现&quot; class=&quot;headerlink&quot; title=&quot;算法实现&quot;&gt;&lt;/a&gt;算法实现&lt;/h4&gt;&lt;p&gt;在之前的&lt;code&gt;max_heapify&lt;/code&gt;函数和&lt;code&gt;create_maxheap&lt;/code&gt;函数的基础上，实现heapsort算法就比较简单了。用自然语言描述的话如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对一个无序array调用&lt;code&gt;create_maxheap&lt;/code&gt;函数，将其转化为一个max heap&lt;/li&gt;
&lt;li&gt;找到array中的最大元素，即array[1]  (根据定义max heap的root上的元素是整个array中最大的)&lt;/li&gt;
&lt;li&gt;交换array[1]和最后一个元素，这样最大的元素到了array的最后&lt;/li&gt;
&lt;li&gt;通过将array的长度减小1来把最后一个元素丢出array&lt;/li&gt;
&lt;li&gt;对缩小长度后的array从第一个元素（亦即heap root）调用&lt;code&gt;max_heapify&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;判断array的长度是否&amp;gt;1，若是则从步骤2继续，否则结束循环&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过这个过程之后，原无序array中的元素就会以非递减的顺序排列。&lt;strong&gt;其本质上就是将在root位置的当前最大元素和当前最后一个元素交换位置，然后再重构整个heap使得缩小长度by 1的那个array再次满足max heap的定义。&lt;/strong&gt;这样就实现了排序的目的。代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;heapsort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[], &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* n is the total nodes in the heap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * i is the start node to call this function&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * n is also the last suffix of array, though total length of array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     is n + 1 (first element of the array is not used.)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    create_maxheap(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;, n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = n; i &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i--)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SWAP(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[i], temp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//printf(&quot;i: %d -&amp;gt; %-5d&quot;, i, array[i]);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//display(array, 11);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        max_heapify2(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;, i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// max_heapify1 ok but max_heapify2 bug&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//printf(&quot;             &quot;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//display(array, 11);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//printf(&quot;\n&quot;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* decrement array size by 1, the biggest sorted item is put there&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        so that when calls max_heapify from root, the sorted part remain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        untouched. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果想要了解是如何通过一次次循环进行排序的，可以取消单行注释，对trace through整个过程有一定的帮助。&lt;/p&gt;
&lt;h4 id=&quot;heapsort算法的时间复杂度分析&quot;&gt;&lt;a href=&quot;#heapsort算法的时间复杂度分析&quot; class=&quot;headerlink&quot; title=&quot;heapsort算法的时间复杂度分析&quot;&gt;&lt;/a&gt;heapsort算法的时间复杂度分析&lt;/h4&gt;&lt;p&gt;分析heapsort的算法时间复杂度，需要看起算法每一步的时间复杂度。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$O(n)$&lt;/li&gt;
&lt;li&gt;一次循环需要$O(1)$， 总共要循环 $n-1$ 次，因此是$O(n)$&lt;/li&gt;
&lt;li&gt;一次循环需要$O(1)$， 总共要循环 $n-1$ 次，因此是$O(n)$&lt;/li&gt;
&lt;li&gt;一次循环需要$O(1)$， 总共要循环 $n-1$ 次，因此是$O(n)$&lt;/li&gt;
&lt;li&gt;一次循环需要$O(\lg n)$， 总共要循环 $n-1$ 次，因此是$O(n\cdot \lg n)$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以heapsort算法的时间复杂度为$O(n\cdot \lg n)$，且易知空间复杂度为$O(n)$，即in place。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前一篇blog&lt;strong&gt;《将未排序数组转化为堆》&lt;/strong&gt;讲了如何将未排序的数组转化成最大堆，本文接着上次的内容继续。主要涉
    
    </summary>
    
      <category term="CS" scheme="http://spencerpomme.github.io/categories/CS/"/>
    
    
      <category term="algorithm" scheme="http://spencerpomme.github.io/tags/algorithm/"/>
    
      <category term="heap" scheme="http://spencerpomme.github.io/tags/heap/"/>
    
      <category term="sort" scheme="http://spencerpomme.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>此消彼长</title>
    <link href="http://spencerpomme.github.io/2016/05/15/%E6%AD%A4%E6%B6%88%E5%BD%BC%E9%95%BF/"/>
    <id>http://spencerpomme.github.io/2016/05/15/此消彼长/</id>
    <published>2016-05-15T14:40:38.000Z</published>
    <updated>2016-05-17T13:49:16.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/flower.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我一直很认同“此消彼长”这个道理。&lt;/p&gt;
&lt;p&gt;高中的时候学理科，物理班。对我来说此消彼长就是能量守恒定律的文艺版说法，很好很简洁。&lt;/p&gt;
&lt;p&gt;你可以自己能量守恒，也可以跟其他人组成一个系统，系统内能量守候。哦，此消彼长。也许这就是为什么若干年前那么流行所谓的“rp守恒定律”吧：&lt;strong&gt;人们总是无法坦然地接受发生在自己身上的种种不幸或失意，哪怕分明自己就是一切祸乱的始作俑者，也莫名地隐隐期望存在这样一种“守恒”，能够让未来的自己因当下的落魄而获益。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;何其自欺欺人。&lt;/p&gt;
&lt;p&gt;rp不是这么攒的啊。避免生活中种种不幸的方法有很多种，但是我知道其中必然不包括不断地扑街、指望这是在预支下半辈子的不幸，心有戚戚焉地说几句豁达开朗的空话，然后希望此后可以一帆风顺——哪怕是一段时间也好呢？不好意思，这个真的不是这么玩儿的啊。我作证。&lt;/p&gt;
&lt;p&gt;消什么，长什么？这个比揪着“此”是哪儿，“彼”是谁要重要得多了。&lt;strong&gt;没有比较就没有伤害&lt;/strong&gt;，做自己家的小孩，让别人家的小孩去上兴趣班吧。代码写得烂又怎样，算法题不会做又如何，实习一直被拒我哭了么？人生不会因此提前终结，这是事实。&lt;/p&gt;
&lt;p&gt;人生会一直持续下去，但失败也是。只要不去主动改变和总结反思自己的问题，不存在神之转折这种便利的东西，不管前边的奇葩遭遇积累了多少。这点不幸跟人类历史上的平均不幸水平比起来简直是个笑话，就算按照“能量守恒”的规律来看，什么也不去做的人只可能趋向于一个更加不幸的状态。&lt;/p&gt;
&lt;p&gt;消除自己的愚蠢和不足，增长自己的能力和见识。&lt;strong&gt;这才是真正的此消彼长。&lt;/strong&gt;自身的无知和狭隘是自己最大的敌人。少部分智者的敌人与自己势均力敌，然而大部分人的敌人是个巨人，个别人的甚至是奇行种。任重而道远，任重而道远。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loser.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是值得终身为之付出努力的伟大事业。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/flower.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我一直很认同“此消彼长”这个道理。&lt;/p&gt;
&lt;p&gt;高中的时候学理科，物理班。对我来说此消彼长就是能量守恒定律的文艺版说法，很好很简洁。&lt;/p&gt;
&lt;p&gt;你可以自己能量守恒，也可以跟其他人
    
    </summary>
    
      <category term="杂谈" scheme="http://spencerpomme.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="心态很重要" scheme="http://spencerpomme.github.io/tags/%E5%BF%83%E6%80%81%E5%BE%88%E9%87%8D%E8%A6%81/"/>
    
  </entry>
  
  <entry>
    <title>将未排序数组转化为堆</title>
    <link href="http://spencerpomme.github.io/2016/05/12/%E5%B0%86%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%A0%86/"/>
    <id>http://spencerpomme.github.io/2016/05/12/将未排序数组转化为堆/</id>
    <published>2016-05-12T09:08:22.000Z</published>
    <updated>2016-05-19T07:34:42.000Z</updated>
    
    <content type="html">&lt;p&gt;本文是由学习MIT 6.006和&lt;strong&gt;Introduction to algorithms&lt;/strong&gt;这本书的笔记转化而来的。虽然之前学习过heap的相关内容，但是通过上课来查缺补漏，发现还是有很多之前遗漏的地方。这篇文章就是讲怎样把一个已经存在的array通过O(1) space转化为一个max/min heap。本文的代码使用C语言。&lt;/p&gt;
&lt;h3 id=&quot;堆的数组存储方式&quot;&gt;&lt;a href=&quot;#堆的数组存储方式&quot; class=&quot;headerlink&quot; title=&quot;堆的数组存储方式&quot;&gt;&lt;/a&gt;堆的数组存储方式&lt;/h3&gt;&lt;p&gt;首先，之所以可以将array转化成heap，是因为heap可以用array来存储。heap在本质上是一棵binary tree，但是由于根据定义，heap同时也是一棵complete binary tree，所以通过array来存储可以通过suffix关系来表示树的parent-child关系，既节省空间又不损失信息。&lt;/p&gt;
&lt;p&gt;假设有一个array A，其中有10个未排序的整数元素：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;] = &amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;45&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;74&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的地方在于，heap从array的第二个元素位置开始存储，既下表为A[1]开始。这样做是为了满足以下关系：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(sudo code)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if parent suffix is i, then:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;left child suffix is 2i,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;right child suffix is 2i + 1.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;根据定义，上边的array A是一棵complete binary tree，其结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/heap1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个结构目前不符合heap的定义（既不是max heap也不是min heap），所以需要对array中的元素进行操作，使得array A满足heap的定义。&lt;/p&gt;
&lt;h3 id=&quot;写一个max-heapify函数&quot;&gt;&lt;a href=&quot;#写一个max-heapify函数&quot; class=&quot;headerlink&quot; title=&quot;写一个max_heapify函数&quot;&gt;&lt;/a&gt;写一个max_heapify函数&lt;/h3&gt;&lt;p&gt;前边说要在O(1) space完成这个变换，即不开另一个array把array A依次按照符合heap定义的次序填装进去，而是在原本的array内进行swap操作。整个过程就是一个in place的heap sort. 在此之前有一个步骤要做，就是构造一个max_heapify函数。&lt;/p&gt;
&lt;p&gt;若一个node的左子树和右子树&lt;strong&gt;均为max heap&lt;/strong&gt;，那么，该node递归向下地&lt;strong&gt;与其左右child比较大小并交换位置&lt;/strong&gt;（当且仅当node小于其child时），并依次向下，直到:（A）node与其左右child满足了max heap的定义; 或（B）node成为了leaf node。严格来讲，(B)是(A)的特殊情况，因为leaf node不存在child，这本身也满足max heap的定义（即leaf nodes always satisfy the definition of max heap). 另外必须明确的一点是，之所以可以在达成条件（A）时停止，是因为根据前提条件，node的左右子树应满足heap的定义。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SWAP(x, y, a) ((a)=(x);(x)=(y);(y)=(a))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MAX(a, b) ((a)&amp;gt;(b))? (a): (b)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;max_heapify&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[], &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* n is the total nodes in the heap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * i is the start node to call this function&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * n is also the last suffix of array, though total length of array is n + 1 (first element of the array is not used.)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i &amp;lt;= n/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;= n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; child = MAX(array[i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], array[i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (child &amp;gt; &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] == child)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    SWAP(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[i], &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], temp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    i *= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (array[i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] == child)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    SWAP(array[i], array[i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], temp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    i = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;lt;= n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (array[i] &amp;lt; array[i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                SWAP(array[i], array[i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], temp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i *= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码采用iteration的写法，虽然有效但是代码逻辑不清晰，也很不优雅。使用recursion的方法来重写，可以更好地看出其中的逻辑：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;max_heapify2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[], &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* n is the total nodes in the heap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * i is the start node to call this function&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * n is also the last suffix of array, though total length of array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     is n + 1 (first element of the array is not used.)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i &amp;gt; n/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp, child;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;= n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        child = MAX(array[i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], array[i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        child = &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (child &amp;gt; &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] == child)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            SWAP(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[i], &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], temp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            max_heapify2(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;, n, i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (array[i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] == child)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            SWAP(array[i], array[i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], temp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            max_heapify2(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;, n, i*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假设对&lt;code&gt;A[2]&lt;/code&gt;这个节点调用&lt;code&gt;max_heapify&lt;/code&gt;函数，就可以看到这个函数的功效了。为了方便观察，写一个&lt;code&gt;display_heap&lt;/code&gt;函数：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;display_heap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[], &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d &quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;调用如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;] = &amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;45&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;74&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    display(A, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    max_heapify1(A, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// max_heapify2(A, 10, 2);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    display(A, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0 2 1 7 8 45 11 23 9 74 4 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 2 45 7 8 4 11 23 9 74 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果根据数组构建二叉树则可以发现，通过调用max_heapify，已经将A[2]这个节点移动到了正确的地方。&lt;/p&gt;
&lt;p&gt;由于max_heapify会从开始的节点递归地向下，直到满足heap定义为止，那么它的时间复杂度该怎样计算呢？简单推倒一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先，对某个节点A[i]调用max_heapify，那么假设以这个节点为root的子树有n个节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为节点A[i]在一棵complete binary tree中，因此以A[i]为root的子树也是一棵complete binary tree&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于一个有n个节点的complete binary tree，从root到leaf的path 为:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;h = lg n&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上所述，在最坏情况下，对于A[i]节点调用max_heapify可能需要从该节点一路比较并swap到leaf才结束，而对于一个有N个元素的heap（或者在这里准确一点，一个complete binary tree)来说，以A[i]为root的子树有&lt;code&gt;c1 * N&lt;/code&gt;个节点，其中c1为一常数且满足&lt;code&gt;0 &amp;lt; c1 &amp;lt;= 1&lt;/code&gt;。所以:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;T(n) = O(lg(c1*N)) = O(lg(N))&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;从array生成max-heap&quot;&gt;&lt;a href=&quot;#从array生成max-heap&quot; class=&quot;headerlink&quot; title=&quot;从array生成max heap&quot;&gt;&lt;/a&gt;从array生成max heap&lt;/h3&gt;&lt;p&gt;因为leaf node总是满足max heap的定义，而对于有n个元素的complete binary tree而言，array[n/2+1], … , array[n]均为leaf node，即这些节点已经满足了max heap的定义，无需调用max_heapify函数进行转化。因此该从i = n/2开始，同时应该是bottom up地向上依次检查节点。这里可以通过定义一个&lt;code&gt;create_heap&lt;/code&gt;函数来完成这个工作。代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;create_maxheap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[], &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = n / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        max_heapify2(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;, n, i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出结果如下，可以发现成功构造了一个max heap：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0 2 1 7 8 45 11 23 9 74 4 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 74 45 23 9 4 11 7 1 8 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在此基础上，就通过O(1) space将一个无序的array构造成了一个max heap。&lt;/p&gt;
&lt;h3 id=&quot;create-maxheap的时间复杂度分析&quot;&gt;&lt;a href=&quot;#create-maxheap的时间复杂度分析&quot; class=&quot;headerlink&quot; title=&quot;create_maxheap的时间复杂度分析&quot;&gt;&lt;/a&gt;create_maxheap的时间复杂度分析&lt;/h3&gt;&lt;p&gt;这部分内容将在下一篇blog中和heap sort一起进行归纳总结。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文是由学习MIT 6.006和&lt;strong&gt;Introduction to algorithms&lt;/strong&gt;这本书的笔记转化而来的。虽然之前学习过heap的相关内容，但是通过上课来查缺补漏，发现还是有很多之前遗漏的地方。这篇文章就是讲怎样把一个已经存在的array
    
    </summary>
    
      <category term="CS" scheme="http://spencerpomme.github.io/categories/CS/"/>
    
    
      <category term="algorithm" scheme="http://spencerpomme.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>一颗敏感的小心脏</title>
    <link href="http://spencerpomme.github.io/2016/05/06/%E4%B8%80%E9%A2%97%E6%95%8F%E6%84%9F%E7%9A%84%E5%B0%8F%E5%BF%83%E8%84%8F/"/>
    <id>http://spencerpomme.github.io/2016/05/06/一颗敏感的小心脏/</id>
    <published>2016-05-06T14:20:38.000Z</published>
    <updated>2016-05-07T03:37:11.000Z</updated>
    
    <content type="html">&lt;p&gt;我很快就要研究生毕业了，满打满算也就还有一年的时间。最近找工作的事情也逐步提上日程，出国一年的导师也再过三四个月就要回国了。前几天参加好朋友女儿的百日宴，碰到了另一个老同学——他的妻子也快生了。而上一次同学聚会，我记得他们才刚领证没多久呢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各种细节提醒着我时间过得有多么的快。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从2014年8月我写下第一行hello world，还有从2015年7月开始脱离研究生导师的工作室全部时间投入到学习computer science中，我已经在写代码的路上走了不小的距离。14年到15年7月之前，因为要做导师的项目（城市规划方向）所以学习的时间非常零散。学习的快乐很快就被缺乏足够学习时间的痛苦所取代，在这种近乎抑郁的情绪中度过了大概8个月，加上做项目经常作息不规律，15年5月体检查出来轻微的肾结石。那个时候我就知道，&lt;strong&gt;不能再这样下去了，违背自己的本心做不愿意做的事情是会死人的&lt;/strong&gt;。回想起来，那个时候的我其实已经出现了一些抑郁症的征兆，很容易就把事情想象得很糟，甚至做好了因为无法跟导师谈拢而退学的觉悟。所幸我的导师刚好要出国一年做访问学者，加之导师断不是那种会为难学生的人，便也做了个顺水人情，准了我不再参与项目的要求。那一次我学到的是，当你做好了最坏的打算并有为此付出代价的觉悟时，事情往往不会真的那么糟：坏运气也怕咬紧牙关打算破釜沉舟的人。&lt;/p&gt;
&lt;p&gt;不做项目之后，每月的补贴自然少了许多，所幸维持基本生活还是可以的。也好，清心寡欲，安心学习，能够有一个安稳的学习环境和连续的学习时间就是我当时的全部渴望。既得顺遂，复何求哉？&lt;/p&gt;
&lt;p&gt;获得自由后的学习效率是很高的。正值暑假，15年的7月和8月我每天的日常就是写代码和跑步。当我一口气跑完10公里的PB缩小到45分钟的时候，我已经从零学习完了C语言，手写过一些基本的数据结构和纯C的练习小项目，积累了大概1万行的代码量。通过学习C语言，对于程序我有了更加接近底层的认识，这是之前学习python的时候所体会不到的。虽然python我也是半吊子水平，但是对于一个摸不到门道乱打乱撞的小白来说，我产生了一丝可笑的安全感：啊，你看我也不是那么糟嘛，我现在会用两种方法写“茴”字了。&lt;/p&gt;
&lt;p&gt;我曾经天真地以为我真的可以凭借自己的一腔热血一直学习下去，从一个彻头彻尾的小白成长为一个如假包换的大牛，而这一切我曾经认为只需要两年。现实用力地打了我的脸。2015年九月我正式跳进了一个叫做算法的坑。两个星期后，我整个人陷入了一种痛苦和不自信当中。在建筑学院这么多年的结果，导致我的逻辑思维处于半休眠的状态，而没有什么比学习算法更加需要大脑以高度抽象和严谨的方式运转了。痛苦中我选择去接了一个城市设计的私活，十天后五千块到手，我也再次重新认识到可以全身心投入cs学习是多么的宝贵，我有多么讨厌在那里做些毫无根据又虚情假意的设计，两眼一闭再次跳进算法这个深坑之中。这一次心态上的反复，九月就这样悄然逝去。&lt;/p&gt;
&lt;p&gt;10月，11月，12月。我在大量的书籍和网上的课程中步履蹒跚地前进。链表、树、堆、图、排序、查找、哈希表，攻城拔寨一般，每掌握一个新的知识都伴随着脑细胞的批量死亡。然而，每天睡醒，再生的脑细胞都比之前更加聪明。我无法声称自己的每一天都过得充实无比，随着时间的推移，留给我的时间在减少，自学的大敌——焦躁，让我付出了惨痛的代价。我开始分神去学习HTML和javascript这种“看得见摸得着”的东西，我怕终日面对抽象的数据结构，学习精妙的算法确最终只是在命令行里输出一个值。畏难情绪和其它诸多因素造成的结果是，经过这三个月的学习，我虽然对算法和数据结构建立基本的认识，也会手写各种算法和数据结构，但是留下了很多知其然不知其所以然的漏洞，这成了我的一个心病。&lt;/p&gt;
&lt;p&gt;其实我很清楚，如果是以找工作为目标，那么认真学习两年实用的技术确实可以找到一份写代码的工作，甚至不需要懂得多少算法。但是正如在我最近重新拾起算法打算逐一攻克之前留下的漏洞时，在&lt;em&gt;Introduction to Algorithms&lt;/em&gt;这本书里在第一章的结尾读到的那样：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;With modern computing technology, you can accomplish some tasks without knowing much about algorithms, but with good background in algorithms, you can do much, much more.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我素来不是一个实用主义者，凡事都希望可以建立系统和透彻的认识，不希望自己的知识仅仅停留在“可以用起来”的程度，也不以“要能用起来”作为学习的唯一甚至主要目标。这一点，可能是我认为在计算机在城市规划中的作用中同我的导师观念不同的地方。&lt;strong&gt;计算机作为一种工具介入到学科中是早已有之；然而作为一种思维方式和知识储备与城市问题发生关联，必然将会产生完全不一样的效果，甚至具有改变整个学科的潜力。&lt;/strong&gt;就像气宗必然胜过剑宗，这只是个时间问题。&lt;/p&gt;
&lt;p&gt;很快2015年就在我的苦闷和惶恐中结束了。&lt;/p&gt;
&lt;p&gt;2016年的伊始我应导师的要求写了一个使用R语言求解回归方程系数的小程序，并将分析结果撰写成文字。这是我写的第一个功能完整的R项目，而且与城市规划相关。在这个项目之后我突然意识到，其实自学这么久，我已经具备了解决城市规划研究中很多问题的能力：真的就是设计一个大概的思路然后做一个API monkey就足以满足大部分需求了。我没有感受到一丝喜悦，反而是满满的恐惧。&lt;strong&gt;所以cs这个坑，到底还有多深呢？&lt;/strong&gt;也许距离我所期望的目标距离真的还是非常遥远，但是我已经初步成长为了一个&lt;strong&gt;可持续性自学的自学者&lt;/strong&gt;：我能发现自己的问题和短板，能找到弥补自己短板的学习资源，并且还有能力通过多种辅助学会这些知识。&lt;/p&gt;
&lt;p&gt;长期在算法的世界中遨游，我就像是一个原力弱成渣又不会使光剑的弱鸡绝地武士。2月的时候我的两个朋友，一个从美帝回来之后一直在经营家族产业，另一个还在美帝读着econ&amp;amp;CS，拉上我一起来写一个web app项目。这个月的主题叫做&lt;strong&gt;论有人带着练级的重要性&lt;/strong&gt;。这段时间是我以一个项目为主要精力投入点写代码最为集中的一个时期，我停下了手头其它的事情，专心就做一件事。我不能声称自己的写代码能力有了多大的提高，但是在心理上产生了一点重要的变化：代码写得长真的可能只是一个长度而已，作为一个初学者不需要给500行、1000行、3000行赋予太多的象征意义，否则只会吓得自己裹足不前。&lt;/p&gt;
&lt;p&gt;三月，我终于说服自己去接受一个现实，就是我不太可能在一毕业就达到自己当初的预期。事实上这样要求自己真的非常不科学：我会在华南理工大学读大学就很能说明我的智商水平不怎么样了，凭什么要求自己一年就能完成一个受到充分训练的科班学生四年才能达成的状态呢？这太自大了，也不利于踏实地学习。既然如此，还是为自己毕业后的出路先铺铺路吧。&lt;/p&gt;
&lt;p&gt;怀着这样的想法，我像甩籽儿一样海投了大量简历，主要是互联网公司的开发岗位和产品岗位。其中大概有1成给了我回音，然后之中的一半给了我笔试的机会，我通过了所有的笔试，但是却都死在了最后一轮面试上。&lt;strong&gt;互联网行业的专业面试官个个看起来聪明机警&lt;/strong&gt;，总是在最后看穿了我就是一个半成品的草包。好吧，我确实代码写得烂又不熟稔产品策划的细枝末节，长期只学算法又没学出什么大门道的“恶果”显现出来了。没办法，我只好在本专业的实习中尽可能挑选与计算机结合的岗位。就这样我去了市院。&lt;/p&gt;
&lt;p&gt;实习了一个月，不得不说我是相当失望的，这也是为什么我只实习了一个月的原因。简单说起来就是我去错部门了（去了一个做历史保护的部门，其中的大数据组原来才刚成立没多久，里边的成员据我所知没有一个会写代码）。我再次清醒地认识到了一个我不愿意承认的事实：城市规划行业，至少在广州，所谓新常态，换汤不换药。所以我如果想做自己感兴趣的事儿，最好不要去这些设计院。不过有趣的一点是，相比起互联网行业求职的步履维艰，去规划院实习简直是畅通无阻。专业对口其一，我的简历其二，行业不景气其三。&lt;/p&gt;
&lt;p&gt;四月，也就是上个月，学习了一下数据库和SQL（这是某次面试的时候一个技术总监给我的建议），然后开始完善我大概一年前烂尾在那里的爬虫。同时开始上MIT的算法课程对自己的知识体系查缺补漏，也就是前边提到的算法导论那本书的课程。中间穿插了一次腾讯的面试，虽然最终被淘汰，但是也是非常有益的经验。有意思的是清华同衡设计院投了简历之后也表示欢迎我去实习，但是考虑到遥远的北京不想跟女票异地，加上打算招我的部门也是处在一个技术刚刚起步的状态（就是个高配版的市院实习经历），我考虑再三还是决定自己好好闭关修炼更加有价值。数学也捡起来，单词也背起来。虽然现在依然是一枚战五渣，但是在正确的道路上有效率地坚持下去，总会有所收获。最重要的是在做自己喜欢的事情，这个不是能用金钱衡量的。&lt;/p&gt;
&lt;p&gt;获得一个CS的学位是我近三到五年内要做的事情中第二重要的事情。至于第一位是什么，当然是要向女票求婚啊。么么哒。&lt;/p&gt;
&lt;p&gt;啰啰嗦嗦写了一大堆，然而日子还要照过，代码还要照写，习还要照学。我知道像我这样自学计算机的人大有人在，如果有一天你看到了这篇文章，我想你知道，你不是孤独的。只不过，我们都必须在孤独中磨砺自己，才能成为一个更厉害的人。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我很快就要研究生毕业了，满打满算也就还有一年的时间。最近找工作的事情也逐步提上日程，出国一年的导师也再过三四个月就要回国了。前几天参加好朋友女儿的百日宴，碰到了另一个老同学——他的妻子也快生了。而上一次同学聚会，我记得他们才刚领证没多久呢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各
    
    </summary>
    
      <category term="杂谈" scheme="http://spencerpomme.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="敏感" scheme="http://spencerpomme.github.io/tags/%E6%95%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>用python写一个豆瓣小组的爬虫（一）</title>
    <link href="http://spencerpomme.github.io/2016/05/01/%E7%94%A8python%E5%86%99%E4%B8%80%E4%B8%AA%E8%B1%86%E7%93%A3%E5%B0%8F%E7%BB%84%E7%9A%84%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://spencerpomme.github.io/2016/05/01/用python写一个豆瓣小组的爬虫（一）/</id>
    <published>2016-05-01T14:34:36.000Z</published>
    <updated>2016-05-10T15:26:06.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;用python写一个豆瓣小组的爬虫（一）&quot;&gt;&lt;a href=&quot;#用python写一个豆瓣小组的爬虫（一）&quot; class=&quot;headerlink&quot; title=&quot;用python写一个豆瓣小组的爬虫（一）&quot;&gt;&lt;/a&gt;用python写一个豆瓣小组的爬虫（一）&lt;/h2&gt;&lt;p&gt;这是一篇夹杂着大量私货的“技术贴”。&lt;/p&gt;
&lt;p&gt;豆瓣是一个神奇的网站。我大概是在07年的时候知道有豆瓣这个网站，然后在高考之后有一段时间整天泡在上边，每看完一部电影就上去标记为“看过”，写个短评，乐此不疲。豆瓣fm也是一个我非常喜欢的功能，我曾经最喜欢的事情之一就是一边听着私人电台，一边在阿尔法城逛来逛去（后来阿尔法城关掉了）。再写下去就要写成豆瓣的软文了，哈。不过确实想说，作为最早的一批90，豆瓣在当时有点像是早几年前的知乎，也像是40年代的魔兽世界，是一个令人怀念的小社区。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.douban.com/group/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;豆瓣小组&lt;/a&gt;不得不说是豆瓣比较成功的一个子产品，当时我初次接触的时候就觉得，“比百度贴吧不知道高到哪里去了”。也许是建筑学的教育背景让我培养了一丝的审美观，也可能是觉得豆瓣小组里的广告虽然也有但远没有那么&lt;strong&gt;人命关天&lt;/strong&gt;，总之，看着舒服。这不算是对豆瓣的夸奖，因为事实上仅仅就产品本身将豆瓣小组与百度贴吧相比较，就足够令人生疑我是不是在黑豆瓣了。不是的，我只是在客观地表达作为一个用户的用户体验而已。&lt;strong&gt;不过需要澄清的是&lt;/strong&gt;，我对于百度的不齿只局限于其决策层的所作所为（或者是不作为？），至于所有勤勤恳恳地码着代码的工程师、产品经理和设计师等等，谁不是在养家糊口呢？&lt;/p&gt;
&lt;p&gt;豆瓣小组确实也不是尽善尽美。豆瓣的数据获取实在不甚方便。之前写地址解析的时候调用过百度的API，用起来十分顺手和方便（毕竟是技术实力雄厚的公司），但是&lt;strong&gt;反观豆瓣的API调用，处处受限，而豆瓣小组干脆则是没有API的&lt;/strong&gt;。在网络上搜集数据，一般来说有API最好，实在没有办法才写爬虫，毕竟前者多快好省而后者不但麻烦还有一点ethical controversy，搞不好容易吃上官司。（当然我这样子的小白就算是写爬虫也不至于惊动到这一步吧，😓）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好吧反正我就是要写一个爬虫，把豆瓣小组中我感兴趣的话题都收入囊中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;以下内容假定读者了解python语法（comfortable about write codes longer than 100 lines）并了解python的包管理，具有对命令行的初步认识。此外，对HTML有个大体的认识会更有助于在阅读后举一反三。&lt;strong&gt;如果你已经比较了解爬虫，这篇博客可能不适合你，&lt;/strong&gt;这篇文章面向的读者是初学者。&lt;strong&gt;但是&lt;/strong&gt;, 就算你都不懂，这篇文章还有一个重要的目标读者群体是&lt;strong&gt;对数据感兴趣的城市规划师&lt;/strong&gt;，这部分同学可以大概了解一下思路，然后去我的github把代码改一改直接就能做关于豆瓣用户的地域空间分布／勾搭od分析／&lt;strong&gt;男(女)p友走遍全国&lt;/strong&gt;，等等这类奇葩的分析了，说不定你的python代码还能&lt;a href=&quot;https://www.zhihu.com/question/30537262&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;写1万行&lt;/a&gt;呢。&lt;/p&gt;
&lt;p&gt;吐槽完毕，下边开始务实。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;一、前期准备&quot;&gt;&lt;a href=&quot;#一、前期准备&quot; class=&quot;headerlink&quot; title=&quot;一、前期准备&quot;&gt;&lt;/a&gt;一、前期准备&lt;/h4&gt;&lt;p&gt;确认你有以下第三方库（我用python3）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.python-requests.org/en/master/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;requests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.crummy.com/software/BeautifulSoup/bs4/doc/#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;beautiful soup 4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pip install requests&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pip install beautifulsoup4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;本文中将会用到这两个第三方库。&lt;/p&gt;
&lt;h4 id=&quot;二、解释本文爬虫的工作原理&quot;&gt;&lt;a href=&quot;#二、解释本文爬虫的工作原理&quot; class=&quot;headerlink&quot; title=&quot;二、解释本文爬虫的工作原理&quot;&gt;&lt;/a&gt;二、解释本文爬虫的工作原理&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;访问网页，把整个页面的源代码抓取下来，分析页面源代码，抽取想要的信息，并存下来。即：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;获取网页&lt;/li&gt;
&lt;li&gt;抽取信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这里，我用requests做抓取这一步，然后用beautifulsoup做分析这一步。虽然自带的urllib挺好的，但是python2和python3的urllib无法兼容，所以采用一个更不容易出问题的。这里的问题是指人犯错，而不是库有bug😂，蛤蛤。&lt;/p&gt;
&lt;p&gt;至于beautifulsoup，我觉得用着很是省心。除了因为暂时没有必(neng)要(li)自己造轮子外，用纯正则表达式来分析HTML的话，差不多可以拍一部电影叫做&lt;em&gt;Fifty shades of rex&lt;/em&gt;了，但我没有这样的爱好，真的。不过话又说回来，五十度灰的男女主角身材真是好，通过强烈刺激观众大脑的某一区域，似乎成功地阻碍了另一部分区域正常发挥作用，这解释了为什么这部电影的豆瓣评分会远远高于我的预想。这外貌协会（又玛丽苏）的世界。&lt;/p&gt;
&lt;p&gt;所以明白了原理，&lt;strong&gt;let’s just shut the f*ck up and write some codes.&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;三、首先，你要有一个…&quot;&gt;&lt;a href=&quot;#三、首先，你要有一个…&quot; class=&quot;headerlink&quot; title=&quot;三、首先，你要有一个…&quot;&gt;&lt;/a&gt;三、首先，你要有一个…&lt;/h4&gt;&lt;p&gt;这个节标题没有任何恶意🐶&lt;/p&gt;
&lt;p&gt;真的，我是指你要有一个&lt;del&gt;女朋友&lt;/del&gt;目标小组。比如这个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/groupiwgf.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;蛤蛤&lt;/p&gt;
&lt;p&gt;下边让我们一步一步来：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#! python3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# code list part 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; requests&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; bs4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# url: the target group&#39;s url&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;url = &lt;span class=&quot;string&quot;&gt;&quot;https://www.douban.com/group/needGF/discussion?start=0&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# now use requests to get the page&#39;s html file&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;html = requests.get(url)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(html)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# to be continued...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也许你是在idle里写的这几行代码，也许是写在记事本里，总之运行它。你会发现整个网页的源码都print出来了。第一步完成啦，excited.&lt;/p&gt;
&lt;h4 id=&quot;三、使用beautiful-soup解析网页&quot;&gt;&lt;a href=&quot;#三、使用beautiful-soup解析网页&quot; class=&quot;headerlink&quot; title=&quot;三、使用beautiful soup解析网页&quot;&gt;&lt;/a&gt;三、使用beautiful soup解析网页&lt;/h4&gt;&lt;p&gt;接着就是抽取想要的信息。本文只想做一步，就是获取帖子的&lt;strong&gt;标题&lt;/strong&gt;，&lt;strong&gt;发帖人&lt;/strong&gt;，&lt;strong&gt;回复数&lt;/strong&gt;，&lt;strong&gt;最后回复时间&lt;/strong&gt;以及&lt;strong&gt;发帖人主页链接&lt;/strong&gt;和&lt;strong&gt;帖子链接&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然而为什么需要链接呢？依我自己的经验，人有的时候真的会抑制不住好奇心去看看发了&lt;strong&gt;“叔帅还霸道，有钱”&lt;/strong&gt;这样子的帖子是何方高富帅，也会想要去围观一下&lt;strong&gt;“楼主女，懂的来”&lt;/strong&gt;这样的帖子，检验一下自己&lt;del&gt;懂不懂&lt;/del&gt;革命意志是否坚定。开玩笑啦，其实保留链接的目的是为了做更为复杂的爬虫，即让爬虫可以继续顺着链接爬下去，这样才有可能得出所有用户的关系图。&lt;/p&gt;
&lt;p&gt;那么让我们来看看怎么做：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# adjacent to code list part 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# this is code list part 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;soup = bs4.BeautifulSoup(html.text, &lt;span class=&quot;string&quot;&gt;&quot;lxml&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# the data are stored in a &amp;lt;table&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;table = soup.findAll(&lt;span class=&quot;string&quot;&gt;&quot;table&quot;&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;class&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;olt&quot;&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# to be continued...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这一步，我们把网页源代码转化成了一个bs4.BeautifulSoup object，这样就可以进行后续的信息抽取了。具体的实现方式不是唯一的，事实上我个人感觉bs4这个库可以有很多方式做到同一件事，教条地说这并不很pythonic。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# adjacent to code list part 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# this is code list part 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# rows are rows in the table&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rows = list(table)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].findAll(&lt;span class=&quot;string&quot;&gt;&quot;tr&quot;&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;class&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; rows:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    title = row.find(&lt;span class=&quot;string&quot;&gt;&quot;td&quot;&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;class&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;title&quot;&lt;/span&gt;&amp;#125;).a.attrs[&lt;span class=&quot;string&quot;&gt;&quot;title&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    title_url = row.find(&lt;span class=&quot;string&quot;&gt;&quot;td&quot;&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;class&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;title&quot;&lt;/span&gt;&amp;#125;).a.attrs[&lt;span class=&quot;string&quot;&gt;&quot;href&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    author = row.find(&lt;span class=&quot;string&quot;&gt;&quot;td&quot;&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;nowrap&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;nowrap&quot;&lt;/span&gt;&amp;#125;).a.text&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    author_url = row.find(&lt;span class=&quot;string&quot;&gt;&quot;td&quot;&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;nowrap&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;nowrap&quot;&lt;/span&gt;&amp;#125;).a.attrs[&lt;span class=&quot;string&quot;&gt;&quot;href&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    follow = row.find(&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; tag: len(tag.attrs)==&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; tag.name==&lt;span class=&quot;string&quot;&gt;&quot;td&quot;&lt;/span&gt;).text&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    time = row.find(&lt;span class=&quot;string&quot;&gt;&quot;td&quot;&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;nowrap&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;nowrap&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;class&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;time&quot;&lt;/span&gt;&amp;#125;).text&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(title, title_url)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(author, author_url)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(follow)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(time)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# let&#39;s call it a day&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过这样子，我们就得到了一页当中的所有帖子的各项信息。如果有任何不懂，参看beautifulsoup的文档。&lt;/p&gt;
&lt;h4 id=&quot;四、距离真正可以使用还差几步&quot;&gt;&lt;a href=&quot;#四、距离真正可以使用还差几步&quot; class=&quot;headerlink&quot; title=&quot;四、距离真正可以使用还差几步&quot;&gt;&lt;/a&gt;四、距离真正可以使用还差几步&lt;/h4&gt;&lt;p&gt;仅仅print出来是不可以接受的，因为一个真正的爬虫还至少需要能够把数据存起来。而且，之前的代码只是爬取了一页，我们还需要在外边套上一层循环。最后，考虑到限制，我们还需要使用代理，或者设置sleep time来慢慢爬，防止被服务器封印掉IP。&lt;/p&gt;
&lt;p&gt;但是我今天累了，劳动节要早点睡。晚安。&lt;/p&gt;
&lt;p&gt;别打我，我其实也没有写完呢。代码见我的GITHUB，或者直接戳这里：&lt;a href=&quot;https://github.com/spencerpomme/screwpie&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;screwpie&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;用python写一个豆瓣小组的爬虫（一）&quot;&gt;&lt;a href=&quot;#用python写一个豆瓣小组的爬虫（一）&quot; class=&quot;headerlink&quot; title=&quot;用python写一个豆瓣小组的爬虫（一）&quot;&gt;&lt;/a&gt;用python写一个豆瓣小组的爬虫（一）&lt;/h2&gt;&lt;
    
    </summary>
    
      <category term="CS" scheme="http://spencerpomme.github.io/categories/CS/"/>
    
    
      <category term="爬虫" scheme="http://spencerpomme.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>c多文件编译的命令行方法（gcc）</title>
    <link href="http://spencerpomme.github.io/2016/04/17/c%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E6%B3%95%EF%BC%88gcc%EF%BC%89/"/>
    <id>http://spencerpomme.github.io/2016/04/17/c多文件编译的命令行方法（gcc）/</id>
    <published>2016-04-17T07:27:07.000Z</published>
    <updated>2016-04-18T06:34:43.000Z</updated>
    
    <content type="html">&lt;p&gt;之前在学习数据结构的时候（现在还没有学完orz）发现，其实学习到后边的树、图之类的数据结构的时候，经常会用到stack和queue这两个更为基础的数据结构，需要经常性地包含它们的头文件。一直以来都直接用IDE来做这个事情，直到有一天觉得每次做题都要新建一个工程然后添加文件很麻烦，就决定把常用数据结构的.c和.h放在一个文件夹里，题目做完了就把problem.c放到这个文件夹里用命令行编译一下就得了。&lt;/p&gt;
&lt;p&gt;其实挺起来好像还是挺麻烦的，不过就当作是增添一项新经验也好。具体做法如下：（以stack.c和stack.h为例）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把需要一起变一的文件都放入一个directory里边去&lt;/li&gt;
&lt;li&gt;&lt;p&gt;cmd/powershell(windows平台)进行如下操作：&lt;/p&gt;
&lt;p&gt; &lt;code&gt;&amp;gt;&amp;gt;&amp;gt; gcc -std=c99 stack.c problem.c -o main&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样在文件夹里就会出现一个名为main.exe的文件了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;之前在学习数据结构的时候（现在还没有学完orz）发现，其实学习到后边的树、图之类的数据结构的时候，经常会用到stack和queue这两个更为基础的数据结构，需要经常性地包含它们的头文件。一直以来都直接用IDE来做这个事情，直到有一天觉得每次做题都要新建一个工程然后添加文件很
    
    </summary>
    
      <category term="CS" scheme="http://spencerpomme.github.io/categories/CS/"/>
    
    
      <category term="gcc" scheme="http://spencerpomme.github.io/tags/gcc/"/>
    
  </entry>
  
</feed>
